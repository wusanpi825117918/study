go run hello.go
go build 生成二进制文件
变量声明
  var d = true
  var vname1, vname2, vname3 = v1, v2, v3
  v_name := value
        package main

        var x, y int
        var (  // 这种因式分解关键字的写法一般用于声明全局变量
            a int
            b bool
        )

        var c, d int = 1, 2
        var e, f = 123, "hello"

        //这种不带声明格式的只能在函数体中出现
        //g, h := 123, "hello"

        func main(){
            g, h := 123, "hello"
            println(x, y, a, b, c, d, e, f, g, h)
        }
     
常量
  const b = "abc"

数组
  var balance [10] float32
  var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}
  不定长
  var balance = [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}
  或
  balance := [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}
  //  将索引为 1 和 3 的元素初始化
  balance := [5]float32{1:2.0,3:7.0}

循环
  for initialisation; condition; post {  
}
  func main() {  
    for i := 1; i <= 10; i++ {
        if i > 5 {
            break // 如果 i > 5 就跳出
        }
        fmt.Printf("%d ", i)
    }
    fmt.Printf("\nline after for loop")
}
func main() {
    age := 10

    switch age {
    case 5:
        fmt.Println("The age is 5")
    case 7:
        fmt.Println("The age is 7")
    case 10:
        fmt.Println("The age is 10")
    default:
        fmt.Println("The age is unkown")
    }
}
func main() {
    age := 7

    switch {
    case age >= 6 && age <= 12:
        fmt.Println("It's primary school")
    case age >= 13 && age <= 15:
        fmt.Println("It's middle school")
    case age >= 16 && age <= 18:
        fmt.Println("It's high school")
    default:
        fmt.Println("The age is unkown")
    }
}

recover错误拦截
 defer func() {
		//设置recover拦截错误信息
		err := recover()
		//产生panic异常  打印错误信息
		if err != nil {
			fmt.Println(err)
		}
	}()
结构体
	type 类型名 struct {
		字段名 字段类型
		字段名 字段类型
		…
	    } 
字符串以。开头strings.HasPrefix(s, prefix string) bool
	strings.HasSuffix(s, suffix string)
	strings.Contains(s, substr string) bool
	Index() 返回字符串 str 在字符串 s 中的索引（str 的第一个字符的索引），-1 表示字符串 s 不包含字符串 str：
		strings.Index(s, str string) int
	strings.LastIndex(s, str string) int
	strings.IndexRune(s string, r rune) int
	strings.Replace(str, old, new string, n int) string
	strings.Count(s, str string) int

if val := 10; val > max {
	// do something
}
	

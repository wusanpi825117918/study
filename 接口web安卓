1、find_element 使用给定的方法定位和查找一个元素
2、find_elements 使用给定的方法定位和查找所有元素 list
常用定位方式共八种：
1.当页面元素有 id 属性时，最好尽量用 by_id 来定位。
2.XPath 很强悍，但定位性能不是很好，所以还是尽量少用。如果确实少数元素不好定位，
那还是选择 XPath 或 cssSelector。
3.当有链接需要定位时，可以考虑使用 by_link_text 或 by_partial_link_text。
el = driver.find_element(By.ID,'kw')
driver.find_element(By.NAME, 'wd').send_keys("电脑")
driver.find_element(By.CLASS_NAME, 's_ipt').send_keys("电脑")
4. 通过tag_name 定位，不常用，相同元素的标签太多了
driver.find_element(By.TAG_NAME, 'input').send_keys("电脑")
5. 通过link_text定位，页面上的文本信息
driver.find_element(By.LINK_TEXT, '新闻').click()
6. 通过partial_link_text定位，模糊查询页面文本信息定位
webdriver-helper自动检测浏览器驱动     from  webdriver-helper.driver import getwebdriver   driver =getwebdriver()          https://www.cnblogs.com/bao-yan/p/16480026.html
driver.find_element(By.PARTIAL_LINK_TEXT, '唐山打人案保').click()

7. xpath定位

1.使用绝对路径定位

/html/body/div/div/div[5]/div/div/span/input

#括号下标从1开始

driver.find_element(By.XPATH, "/html/body/div/div/div[5]/div/div/form/span/input").send_keys('123')

2. 利用元素属性定位,//表示相对路径

//input[@id=’kw’]

//*[@id='kw']

*表示不知道什么属性的时候

driver.find_element(By.XPATH, "//input[@id='kw']").send_keys('123')

3. 利用父子关系以及元素定位

//form[@id='form']/span/input

driver.find_element(By.XPATH, "//form[@id='form']/span/input").send_keys('123')

4. 使用逻辑运算符定位

利用其中的两个元素定位例如id+class

例：

元素a：id=9 name=x

元素b: id=9 name=y

元素c：id=99 name=x

定位属性a比较麻烦id和name都有重复的

使用and 或者 or

driver.find_element(By.XPATH, "//input[@id='kw' and @name='wd']").send_keys('123')

CSS定位

CSS_SELECTOR

1.类选择器

类选择器.class属性

driver.find_element(By.CSS_SELECTOR, '.s_ipt').send_keys('123')

2. id选择其

#id属性

driver.find_element(By.CSS_SELECTOR, "#su").click()

3. 表示父子关系定位

Form#form>span >input

driver.find_element(By.CSS_SELECTOR, 'form#form>span >input').send_keys('123')
浏览器操作
          1、浏览器窗口大小设置
          # 设置浏览器宽 480、高 800
          driver.set_window_size(480, 800)
          # 浏览器窗口最大化
          driver.maximize_window()
          2、浏览器页面前进后退
          # 前进
          driver.forward()
          # 后退
          driver.back()
          3、浏览器页面刷新
          # 刷新
          driver.refresh()
          4、浏览器关闭
          # 关闭当前窗口
          driver.close()
          # 退出驱动并关闭所有关联的窗口
          driver.quit()
下拉菜单操作    
                    1、使用 Select 类来处理下拉菜单
                    select = Select(driver.find_element_by_id('select-demo'))
                    # 通过 value 来选择，例如：香蕉
                    select.select_by_value('banana')
                    # 通过 index 来选择（从 0 开始），例如：葡萄
                    select.select_by_index(2)
                    # 通过 text 来选择，例如：苹果
                    select.select_by_visible_text('苹果')
 # 隐式等待
driver.implicitly_wait(5)
try:
 driver.find_element_by_id("su").click()
except NoSuchElementException as msg:
 print(msg)
 # 判断 id 为 kw 元素是否可见
element = WebDriverWait(driver,5,0.5).until(lambda x: x.find_element_by_id("kw").is_displayed())
多表单切换
          1、switch_to.frame() 默认可以直接取表单的 id 或 name 属性进行切换，也可以用 Xpath 等。
          例如：
          driver.switch_to.frame("frameA")
          driver.switch_to.frame(driver.find_element_by_xpath("//iframe[@src='frame2.html']"))
          2、switch_to.parent_frame() 跳出当前层
          3、switch_to.default_content() 返回最外层
 多窗口切换
          driver.current_window_handle 获得当前窗口句柄
          window_handles 获取所有窗口句柄
          switch_to.window() 切换窗口
 接口
          requests.get(url='http://httpbin.org/get',params=data,headers=headers)/json单引号
          res.encoding='utf-8'
          print(res.status_code)         
          print(res.headers)         
          print(res.text)      
          print(res.json())
 unittest        
           suite = unittest.TestSuite()
           suite.addTest(TestDemo('test_case2'))
           suite.addTest(TestDemo('test_case1'))
           runner = unittest.TextTestRunner(verbosity=2)
           runner.run(suite)
          class TEST(unittest.TestCase):
              @classmethod
              def setUpClass(cls):
                  print('setUpClass')
              @classmethod
              def tearDownClass(cls):
                  print('teartDownClass')
              def setUp(self):
                  print('setUp')
              def tearDown(self):
                  print('tearDown')
              def test_001(self):
                  self.assertEqual(1+1,2,'用例失败')
                  
          if __name__ == '__main__':
              unittest.main()
          @unittest.skip(reason)：skip(reason)装饰器，无条件跳过装饰的测试，并说明跳过测试的原因。
          @unittest.skipIf(reason)：skipIf(condition,reason)装饰器，条件为真时，跳过装饰的测试，并
          说明跳过测试的原因。
          @unittest.skipUnless(reason)：skipUnless(condition,reason)装饰器，条件为假时，跳过装饰的
          测试，并说明跳过测试的原因。
          @unittest.expectedFailure：测试标记为失败。
          
拖拽滚动条dr.execute_script('document.documentElement.scrollTop=10000')
打开一个新的Window
driver.get("https://www.google.com/");
// Opens a new window and switches to new window
driver.switchTo().newWindow(WindowType.WINDOW);
 
// Opens BrowserStack homepage in the newly opened window
driver.navigate().to("https://www.browserstack.com/");
打开一个新的Tab页（同一个浏览器）
driver.get("https://www.google.com/");
 
// Opens a new tab in existing window
driver.switchTo().newWindow(WindowType.TAB);
 
// Opens Browserstack homepage in the newly opened tab
driver.navigate().to("https://www.browserstack.com/");
8. Actions类的一些改动
Actions类通常用来模拟用户的鼠标和键盘操作某些特定的元素。（比如左击，右击，双击等）

在Selenium 4 中，添加了以下的方法：
action = ActionChains(driver)
click(WebElement)
代替：moveToElement(onElement).click()

作用：点击某个元素

clickAndHold(WebElement)
代替： moveToElement(onElement).clickAndHold()

作用：点击某个元素并且不放

contextClick(WebElement)
代替： moveToElement(onElement).contextClick(）

作用：右击某个元素

doubleClick(WebElement)
代替： moveToElement(element).doubleClick()

作用：双击某个元素

release()
代替： 原来是org.openqa.selenium.interactions.ButtonReleaseAction类的一部分，现在加到Actions类中

作用：松开某个元素
